#!/usr/bin/env python

import os
import re
import subprocess
import sys

# determine if local or ssh (local -> "urxvt", remote -> "sshd"):
# cat /proc/$PPID/status | head -1 | cut -f2


# forks the process
def spawnDaemon(func, *args):
    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    try:
        pid = os.fork()
        if pid > 0:
            # parent process, return and keep running
            return
    except OSError as exc:
        print >>sys.stderr, "fork #1 failed: %d (%s)" % (exc.errno, exc.strerror)
        sys.exit(1)

    os.setsid()

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as exc:
        print >>sys.stderr, "fork #2 failed: %d (%s)" % (exc.errno, exc.strerror)
        sys.exit(1)

    # do stuff
    func(*args)

    # all done
    os._exit(os.EX_OK)


if sys.argv[1:]:
    line = " ".join(sys.argv[1:])
else:
    line = subprocess.check_output("xclip -o".split()).decode('8859').strip()

if not line:
    raise ValueError("no reasonable file info to work from")

regexs = (  # noqa: W605
    '^([^\s]+)\s+\d+\s+\d+\s+\d+\%\s+(\d+)-?',  # noqa: W605
    r'^#\d+ (.*)?\((\d+)\):',
    r'File "(.*)", line (\d+)',
    r'(.*):(\d+):(\d+):',
    r'(.*):(\d+):',
    r'(.*):(\d+)',
)

filename = line.split()[0]
linenum = None
colnum = None

for regex in regexs:
    matchobj = re.match(regex, line)
    if matchobj:
        # todo: find better way to do this
        # filename, linenum, colnum = matchobj.groups()
        captures = matchobj.groups()
        filename = captures[0]
        linenum = captures[1]
        if len(captures) > 2:
            colnum = captures[2]
        break

cmd = ["xfce4-terminal", "-e"]
nvim_cmd = ["nvim"]

file_to_call = filename.split(':')[0]
file_to_call = file_to_call.replace("/drone/src/blackwidow", "/home/jtprince/dev/blackwidow/blackwidow")
file_to_call = file_to_call.replace("/thanos", "/home/jtprince/dev/crux-api")

# once we switch top level docker image dir to crux or something else:
# file_to_call = file_to_call.replace("/crux-api", "/home/jtprince/dev/crux-api")

# Sometimes we get a module path:
if "/" not in file_to_call:
    file_to_call = file_to_call.replace(".", "/")
    file_to_call = file_to_call + ".py"

# Sometimes the module path starts with '=='
if file_to_call.startswith("=="):
    file_to_call = file_to_call.replace("==", '', 1)

nvim_cmd.append(file_to_call)

if colnum:
    # nvim can't do the call cursor() :(
    nvim_cmd.extend(["-c", ":call cursor({}, {})".format(linenum, colnum)])
elif linenum:
    nvim_cmd.extend(["-c", ":{}".format(int(linenum))])


nvim_str = " ".join(nvim_cmd)
cmd.append(nvim_str)

print(f"running: {' '.join(cmd)}")

spawnDaemon(subprocess.call, cmd)

# Example lines

# python
#  File "/home/jtprince/dev/doba.com/doba/apps/loggedout/tests.py", line 606, in test_HotProductsView
#  File "scratch.py", line 7, in <module>
# ./doba/apps/loggedout/views.py:698:33: E261 at least two spaces before inline comment
# ruby:
# /home/jtprince/bin/id3_rename.rb:5: syntax error, unexpected tIDENTIFIER, expecting end-of-input
# flake8
# ./doba/settings/common.py:325:1: E265 block comment should start with '# '
# django_utils.tests.test_utils:34
# ==django_utils.tests.test_utils:34

#  File "/drone/src/blackwidow/libs/utils/tests/test_json.py", line 41, in test_object_with_to_dict
