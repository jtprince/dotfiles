#!/usr/bin/env python3
"""
Find opposite polarity msrun_id pairs.

Given one or more msrun_ids, finds their opposite polarity pairs from
Benchling. MSruns of opposite polarity are paired by sample_description pattern.

Output format:
  positive_id:negative_id (one pair per line)
  
If an msrun_id has no opposite polarity pair, it's omitted from output.
"""

import argparse
import re
import sys
from enveda_toolkit import get_databricks


def extract_pattern(sample_desc: str) -> str | None:
    """
    Extract the pairing pattern from a sample_description.

    Examples:
        "PS211214_S100_1to243_1-C,1_5_1710.d" -> "PS211214_S100_1to243_1-C,1_5_"
        "RS513_260127-1156" -> "RS513_260127-"
    
    Returns the prefix before the last number.
    """
    if not sample_desc:
        return None

    # Try format with .d extension
    match = re.match(r"^(.+[_-])(\d+)\.d$", sample_desc)
    if match:
        return match.group(1)

    # Try format without .d
    match = re.match(r"^(.+[_-])(\d+)$", sample_desc)
    if match:
        return match.group(1)

    return None


def get_all_polarity_pairs(
    msrun_ids: list[str], env: str = "prod"
) -> dict[str, tuple[str, str, str]]:
    """
    Find opposite polarity pairs for multiple msrun_ids in a single query.

    Args:
        msrun_ids: List of msrun_ids to find pairs for
        env: Environment to query ("prod" or "dev")

    Returns:
        Dict mapping input msrun_id to (input_id, opposite_id, polarity) tuple
    """
    dbx = get_databricks(env)

    msrun_ids_str = "', '".join(msrun_ids)

    # Single query: get input runs and all runs in one go
    # We'll do pattern matching in Python
    query = f"""
    SELECT `file_registry_id$` as msrun_id,
           sample_description,
           ionization_mode,
           CASE 
               WHEN `file_registry_id$` IN ('{msrun_ids_str}') THEN 1
               ELSE 0
           END as is_input
    FROM benchling_raw.bruker_mass_spec_run
    WHERE sample_description IS NOT NULL
    """

    df = dbx.query_df(query)

    if df.empty:
        return {}

    # Split into input and all runs
    input_df = df[df["is_input"] == 1].copy()
    all_df = df.copy()

    # Add pattern column
    input_df["pattern"] = input_df["sample_description"].apply(extract_pattern)
    all_df["pattern"] = all_df["sample_description"].apply(extract_pattern)

    # Remove nulls
    input_df = input_df[input_df["pattern"].notna()]
    all_df = all_df[all_df["pattern"].notna()]

    results = {}

    # For each input, find the opposite polarity with same pattern
    for _, input_row in input_df.iterrows():
        input_id = input_row["msrun_id"]
        pattern = input_row["pattern"]
        polarity = input_row["ionization_mode"]

        # Find opposite polarity with same pattern
        opposite_polarity = (
            "ESI Negative" if polarity == "ESI Positive" else "ESI Positive"
        )

        matches = all_df[
            (all_df["pattern"] == pattern)
            & (all_df["ionization_mode"] == opposite_polarity)
            & (all_df["msrun_id"] != input_id)
        ]

        if not matches.empty:
            opposite_id = matches.iloc[0]["msrun_id"]
            results[input_id] = (input_id, opposite_id, polarity)

    return results


def format_pair(
    msrun_id: str, opposite: str, polarity: str, format_type: str
) -> str:
    """
    Format a polarity pair for output.

    Args:
        msrun_id: Input msrun_id
        opposite: Opposite polarity msrun_id
        polarity: Polarity of input msrun_id ("ESI Positive" or "ESI Negative")
        format_type: Output format ("colon", "tab", "json")

    Returns:
        Formatted string with positive:negative order
    """
    # Always put positive first, then negative
    if "positive" in polarity.lower():
        pos, neg = msrun_id, opposite
    else:
        pos, neg = opposite, msrun_id

    if format_type == "colon":
        return f"{pos}:{neg}"
    elif format_type == "tab":
        return f"{pos}\t{neg}"
    elif format_type == "json":
        return f'{{"positive": "{pos}", "negative": "{neg}"}}'
    else:
        return f"{pos}:{neg}"


def parse_args():
    parser = argparse.ArgumentParser(
        description=(
            "Find opposite polarity msrun_id pairs. "
            "Output: positive_id:negative_id"
        ),
        epilog=(
            "Examples:\n"
            "  %(prog)s MSB123456\n"
            "  %(prog)s MSB123456 MSB789012\n"
            "  %(prog)s MSB123456 --format tab\n"
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "msrun_ids",
        nargs="+",
        help="One or more msrun_id values",
    )
    parser.add_argument(
        "--env",
        choices=["dev", "prod"],
        default="prod",
        help="Databricks environment (default: prod)",
    )
    parser.add_argument(
        "--format",
        choices=["colon", "tab", "json"],
        default="colon",
        help="Output format (default: colon)",
    )
    parser.add_argument(
        "--show-missing",
        action="store_true",
        help="Show msrun_ids that have no opposite polarity pair",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    # Get all pairs in a single query
    pairs = get_all_polarity_pairs(args.msrun_ids, env=args.env)

    found_count = 0
    missing_count = 0

    for msrun_id in args.msrun_ids:
        if msrun_id in pairs:
            input_id, opposite_id, polarity = pairs[msrun_id]
            output = format_pair(input_id, opposite_id, polarity, args.format)
            print(output)
            found_count += 1
        else:
            if args.show_missing:
                print(
                    f"# No opposite polarity pair found for {msrun_id}",
                    file=sys.stderr,
                )
            missing_count += 1

    # Exit with non-zero if any were missing (unless we're showing them)
    if missing_count > 0 and not args.show_missing:
        sys.exit(1)


if __name__ == "__main__":
    main()
